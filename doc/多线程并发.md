# 多线程并发

### 什么是线程，什么是进程



### 生成线程有几种方法，启动线程有几种方法

### Java分为两种线程：本地线程和守护线程

守护线程：指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因 此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。

用户线程：自己创建的线程。比如：new Thread。这就是自己创建了一个线程。

守护线程和用户线程的没啥本质的区别：唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了。 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。

### Java 中用到的线程调度算法是什么

FIFS先来先服务调度算法



　　特点：算法简单，但是效率低；有利于长作业，不利于短作业；有利于CPU繁忙型作业而不利于IO繁忙型作业。
王道考研操作系统知识点整理



### SJF短作业优先调度算法



　　短作业（进程）优先调度算法是指对短作业祸端进程优先调度的算法。短作业优先调度算法是从后备队列中选择一个或若干个估计运算时间最短的作业，将他们调入内存运行。



## 线程拥有几种状态

### 那些是JVM管理，那些是操作系统管理

### 线程什么时候被挂起，挂起是否也是一种状态



## 常用方法

### sleep()

### yield()

### join()

### getState()



## 锁

### synchronized

#### 锁升级


    一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个
线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将
对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。
一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。
        轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转


偏向锁->自旋锁->重量级锁

#### 线程八锁

#### 可重入锁

#### 异常锁释放

### 锁粒度

### synchronized原子性，可见性，有序性

+ 原子性 ：加锁，释放锁，objectMonitor
+ 可见性，加了load屏障和Store屏障，释放锁flush数据，加速会refresh数据
+ 有序性：Acquire的屏障和Release屏障，保证同步代码快内部的指令重排序，但内部和外部不可以重排序

### synchronized底层原理

monitorenter,monitorexit



![](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/98043400_1582505695.jpg)

## JMM(java内存模型)

### 原子性

### 可见性

### 有序性

#### happens-before

编译器、指令器可能对代码重排序，乱排，要守一定的规则，happens-before原则，只要符合happens-before的原则，那么就不能胡乱重排，如果不符合这些规则的话，那就可以自己排序

1. **程序次序规则**：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
2. **锁定规则**：一个unLock操作先行发生于后面对同一个锁的lock操作，比如说在代码里有先对一个lock.lock()，lock.unlock()，lock.lock()
3. **volatile变量规则**：对一个volatile变量的写操作先行发生于后面对这个volatile变量的读操作，volatile变量写，再是读，必须保证是先写，再读
4. **传递规则**：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
5. **线程启动规则**：Thread对象的start()方法先行发生于此线程的每个一个动作，thread.start()，thread.interrupt()
6. **线程中断规则**：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
7. **线程终结规则**：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
8. **对象终结规则**：一个对象的初始化完成先行发生于他的finalize()方法的开始

## volatile

### 可见性

#### 可见性硬件层面可能发生的原因

+ 每个cpu都有一个寄存器，各自线程在不同cpu运行计算时，放在寄存器里的数据不透明
+ 写在高速缓存和写缓存中还没有写进主内存

lock 会把数据立刻刷到主内存，其他线程会嗅探到你对值的修改

#### 



#### MESI



### 禁止重排序

指令重排会发生的位置，编译器，cpu,内存指令

重排序位置

![重排序位置](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/58092200_1582205147.jpg)

处理器猜测执行

#### 高速缓存和写缓冲器的内存重排序造成的视觉假象

![](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/36253800_1582505135.jpg)



这个内存重排序，有4种可能性：

 

（1）LoadLoad重排序：一个处理器先执行一个L1读操作，再执行一个L2读操作；但是另外一个处理器看到的是先L2再L1

 

（2）StoreStore重排序：一个处理器先执行一个W1写操作，再执行一个W2写操作；但是另外一个处理器看到的是先W2再W1

 

（3）LoadStore重排序：一个处理器先执行一个L1读操作，再执行一个W2写操作；但是另外一个处理器看到的是先W2再L1

 

（3）StoreLoad重排序：一个处理器先执行一个W1写操作，再执行一个L2读操作；但是另外一个处理器看到的是先L2再W1

 

给大家举个例子，比如说写缓冲器为了提升性能，有可能先后到来W1和W2操作了之后，他先执行了W2操作，再执行了W1操作。那这个时候其他处理器看到的可不就是先W2再W1了，这就是StoreStore重排序

### 不保证原子性

特例能保证32位Java虚拟机中的long和double

 原子性这块，特例，32位虚拟机里的long/double类型的变量的简单赋值写操作，不是原子的，long i = 30，double c = 45.0，在32位虚拟机里就不是原子的，因为long和double是64位的

如果多个线程同时并发的执行long i = 30，long是64位的，就会导致有的线程在修改i的高32位，有的线程在修改i的低32位，多线程并发给long类型的变量进行赋值操作，在32位的虚拟机下，是有问题的

#### DCL单例

单例双重检查，要不要加volatile



## synchronized与volatile区别

硬件层面的原理 -> MESI协议在硬件层面运行的原理 -> 这套原理为何会导致可见性和有序性的问题 -> 各种内存屏障是如何在硬件层面解决可见性和有序性的问题 -> volatile和synchroized是如何加各种内存屏障来分别保证可见性和有序性的

## CAS

解决synchronized加锁，串行化，效率并不是太高，很多线程，都需要排队去执行

### cas 底层实现

CAS在底层的硬件级别给你保证一定是原子的，同一时间只有一个线程可以执行CAS，先比较再设置，其他的线程的CAS同时间去执行此时会失败

### ABA问题





## Atomic类

### 为什么Atomic 比 synchronized 快



### LongAdder 为什么比Atomicx 快

分段锁

## ReentrantLock

默认非公平锁

### AQS

![](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/30105000_1578391043.png)

### 常用方法

#### tryLock()

#### lock.lockInterruptibly()

#### 公平锁

## ReentrantLock 与 synchronized 对比



## CountDownLatch



## CyclicBarrier



## Phaser



## ReadWriteLock



## Semaphore



## Exchanger



## LockSupport



### LockSupport.park与LockSupport.unpark总结

### 



## ThreadLocal

### ThreadLocal 源码

### 强软弱虚



# 集合

## copyOnWrite



## ConcurrentHashMap 

解决hashmap 不同线程访问 不同位置，synchronized，也没这个必要

1.7之前分段锁，1.8以后每个元素都加锁基于cas



写时复制，多读少写的情况

### 队列



# 线程池

## 原理

![](http://wechatapppro-1252524126.file.myqcloud.com/image/ueditor/3348600_1578391152.png)

## 核心参数

8核32线程

## 面试题

### 如果在线程中使用无界阻塞队列会发生什么问题

oom

### 线程池的队列满了之后，会发生什么事情吗

你可以无限制的不停的创建额外的线程出来，一台机器上，有几千个线程，甚至是几万个线程，每个线程都有自己的栈内存，占用一定的内存资源，会导致内存资源耗尽，系统也会崩溃掉

自定义一个reject策略，如果线程池无法执行更多的任务了，此时建议你可以把这个任务信息持久化写入磁盘里去，后台专门启动一个线程，后续等待你的线程池的工作负载降低了，他可以慢慢的从磁盘里读取之前持久化的任务，重新提交到线程池里去执行

### 如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？

必然会导致线程池里的积压的任务实际上来说都是会丢失的

如果说你要提交一个任务到线程池里去，在提交之前，麻烦你先在数据库里插入这个任务的信息，更新他的状态：未提交、已提交、已完成。提交成功之后，更新他的状态是已提交状态

系统重启，后台线程去扫描数据库里的未提交和已提交状态的任务，可以把任务的信息读取出来，重新提交到线程池里去，继续进行执行



### 32位Java虚拟机中的long和double变量写操作为何不是原子的？

如果多个线程同时并发的执行long i = 30，long是64位的，就会导致有的线程在修改i的高32位，有的线程在修改i的低32位，多线程并发给long类型的变量进行赋值操作，在32位的虚拟机下，是有问题的

 就可能会导致多线程给long i = 30赋值之后，导致i的值不是30，可能是-3333344429，乱码一样的数字，就是因为高低32位赋值错了，就导致二进制数字转换为十进制之后是一个很奇怪的数字



### 线程池原理，线程池有哪些，线程池工厂有哪些线程类型，及参数

1. newCachedThreadPool (ThreadPoolExecutor)

   > 创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程,那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。

2. newFixedThreadPool (ThreadPoolExecutor)

   > 创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。

3. newSingleThreadExecutor (ThreadPoolExecutor)

   > 创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。

4. newScheduledThreadPool (ScheduledThreadPoolExecutor)

   > 创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。

5. newSingleThreadScheduledExecutor (ScheduledThreadPoolExecutor)

   > 创建一个单线程用于定时以及周期性执行任务的需求。

6. newWorkStealingPool (1.8 ForkJoinPool)

   > 创建一个工作窃取


# 重构

## 坏味道

+ 重复代码

+ 过长函数

  ​	提炼信号，不超过50行

  + 需要注释的代码，就应该考虑提炼函数，试着用方法名代替注释
  + 条件表达式
  + 循环

+ 过长参数

  ​	不超过3个参数

+ 过大的类

  ​	不超过500行

+ 发散式变化

  ​	一个工具类7个函数，如果添加一个新的依赖，需要修改3个函数，添加另一个依赖，需要修改另外4个函数，就建议将这个类拆分为俩个类

+ 霰弹式修改

  ​	如果添加一个依赖，需要在很多个类中小修改，就考虑把这些小修改提炼到一个类

+ 依赖情结

  ​	如果一个类的方法，对于另一个类过于依赖，比如A#a,调用B半数以上方法，就建议将a挪到B

+ 数据泥团

  ​	两个类相同的字段，许多函数相同的参数，需要考虑结合

+ 基本类型偏执

  ​	尽量使用对象，充当参数

+ 少使用switch

  ​	尽量减少switch使用，比如使用多态替换他

+ 平行继承体系

  ​	每当你为一个类增加一个子类，就必须也为另一个类相对应增加一个子类，你就要考虑多重继承

+ 赘余类

  ​	没有必要的类，试着合并到其他类中

+ 只比目标多一步

  ​	可以考虑未来，但不要考虑太远，比现实多一步就可以

+ 临时字段

  ​	提炼对立的对象

+ 过度耦合的消息链

  ​	避免A->B->C->D,A通过B再通过C再通过D获得信息

+ 中间人

  ​	过多使用代理，有很多不干实事的函数

+ 过于亲密关系

  ​	两个类互相试图调用彼此的private类，这时候试着提炼公共方法

+ 异曲同工的类

  ​	俩个函数坐同一件事，但参数列表不同，这时候试着提炼公共方法

+ 不完美的类库

  ​	为不完美的类库，封装

+ 纯稚的数据类

  ​	pojo封装赋值，取值，字段私有化

+ 被拒绝的遗赠

  ​	子类不想继承父类的所有方法和属性，只想继承部分内容

+ 过多的注释

  ​	代码清晰，不需要过多的注释

## 重构手段

### 重新组织函数

+ 提炼函数

  ​	用函数名取代注释，每个函数的粒度都应该尽量小

  + 注意多种临时变量的情况

+ 内联函数

  ​	在函数调用点插入函数本体，然后移除该函数，避免不必要的间接层

+ 内联临时变量

+ 以查询取代临时变量

  + 注意存在类加的计算的情况，可以使用final
  + 不要太在意性能问题

+ 引入解释性变量

  ​	条件判断时，利用临时变量，代替复杂判断条件

+ 分解临时变量

  ​	当一个临时变量，不是循环变量，也不是类加变量时，又被重复赋值，就要考虑单独抽离新的临时变量

+ 移除对参数的赋值

  ​	如果要对参数赋值，就为参数设置一个中间变量
  
+ 以函数对象取代函数

  ​	将这个函数放进一个单独对象中，如此一来局部变量就变成对象内的字段，然后你可以在同一个对象中将这个大型函数分解成为多个小函数

+ 替换算法

### 对象之间的转移

+ 搬移函数

  ​	将函数挪到更多使用的类

+ 搬移字段

  ​	将字段挪到更多使用的类

+ 提炼类

  ​	建立一个新类，将相关的字段和函数从旧类搬到新类

+ 对类内联化

  ​	将这个类所有的特性搬到另一个类，然后移除原类

+ 隐藏委托关系

  ​	在服务器类上建立客户所需要的所有函数，用以隐藏委托关系

+ 移除中间人

  ​	大量出现隐藏委托关系，就该移除中间人

+ 引入外加函数

  ​	函数参数用对象代替具体值

+ 引入本地扩展

  ​	对于不可更改的类作为参数，当需要扩展时，可考虑继承或包装

### 重新组织数据

+ 自封装字段

  ​	get().set()

+ 以对象取代数据值

+ 值对象改为引用对象

+ 引用对象改为值对象

  ​	很小且不可变时

+ 以对象取代数组

+ 复制被监视的数据

+ 单向关联改为双向关联

+ 双向关联改单向关联

+ 字面常量取代魔法数

+ 封装字段

  声明字段private ，get()

+ 封装集合

+ 字段取代子类